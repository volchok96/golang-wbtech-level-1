package main

import (
	"fmt"
)

// К каким негативным последствиям может привести данный фрагмент кода, и как это исправить?
// Приведите корректный пример реализации.

//var justString string
//func someFunc() {
//	v := createHugeString(1 << 10)
//	justString = v[:100]
//}
//
//func main() {
//	someFunc()
//}

//Данный фрагмент кода может привести к нескольким негативным последствиям:
//
// 1. Проблема с выделением памяти:
//
// Переменная justString хранит подстроку из createHugeString, которая ссылается на ту же область памяти, что и оригинальная
// строка v. Это значит, что вся память, выделенная для v, не будет освобождена, пока justString используется.
// Это может привести к утечке памяти, особенно если v очень большая строка,
// а justString хранит только небольшую часть этой строки.
//
// 2. Возможная проблема с некорректным использованием Unicode:
//
//Строки в Go являются UTF-8, и простое обрезание строки может нарушить кодировки символов, если обрезка происходит
//посередине многобайтового символа.

var justString string 

func createHugeString(size int) string {
	return string(make([]byte, size))
}

// someFunc безопасно обрезает строку до первых 100 символов
// и сохраняет результат в глобальную переменную `justString`.
func someFunc() {
	v := createHugeString(1 << 10) // Создаем большую строку размером 1024 байта

	// Преобразуем строку в срез рун для корректной работы с Unicode
	runes := []rune(v)

	// Проверяем, что длина больше 100 рун, чтобы избежать паники при обрезке
	if len(runes) > 100 {
		justString = string(runes[:100]) // Берем первые 100 рун и создаем новую строку
	} else {
		justString = string(runes) // Если строка короче 100 рун, берем всю строку
	}

}

func main() {
	someFunc()
	fmt.Println(justString) // Выводим первые 100 символов строки
	fmt.Println(len(justString))
}
